package lima

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/davidsenack/agentbox/internal/config"
)

const limaTemplateContent = `# AgentBox Lima VM Configuration
# Generated by agentbox - do not edit manually

vmType: "vz"
vmOpts:
  vz:
    rosetta:
      enabled: true
      binfmt: true

cpus: {{ .Config.VM.CPUs }}
memory: "{{ .Config.VM.Memory }}"
disk: "{{ .Config.VM.Disk }}"

images:
  - location: "https://cloud-images.ubuntu.com/releases/24.04/release/ubuntu-24.04-server-cloudimg-arm64.img"
    arch: "aarch64"
  - location: "https://cloud-images.ubuntu.com/releases/24.04/release/ubuntu-24.04-server-cloudimg-amd64.img"
    arch: "x86_64"

# CRITICAL: Only mount workspace and artifacts - nothing else
mounts:
  - location: "{{ .WorkspacePath }}"
    mountPoint: "/workspace"
    writable: true
  - location: "{{ .ArtifactsPath }}"
    mountPoint: "/artifacts"
    writable: true

# Network: use Lima's default networking (user-v2)
# This provides outbound internet access and host connectivity via socket forwarding

# SSH configuration - no forwarding
ssh:
  localPort: 0
  forwardAgent: false
  forwardX11: false

# Provision scripts run as root
provision:
  - mode: system
    script: |
{{ .ProvisionScript | indent 6 }}

# Readiness probe
probes:
  - mode: readiness
    description: "Waiting for agentbox setup"
    script: |
      #!/bin/bash
      test -f /etc/agentbox-ready
    hint: "Run 'agentbox reset <name>' if this fails"

# Environment propagation is disabled - secrets injected explicitly
propagateProxyEnv: false

# Plain mode disabled - we need cloud-init for user creation
plain: false

# CA certificates - keep defaults
caCerts:
  removeDefaults: false

# Containerd disabled - no Docker socket
containerd:
  system: false
  user: false
`

func indent(spaces int, v string) string {
	pad := strings.Repeat(" ", spaces)
	lines := strings.Split(v, "\n")
	for i, line := range lines {
		if line != "" {
			lines[i] = pad + line
		}
	}
	return strings.Join(lines, "\n")
}

// GenerateTemplate creates a Lima YAML template for the given configuration
func GenerateTemplate(cfg *config.Config, projectDir string) (string, error) {
	funcMap := template.FuncMap{
		"indent": func(spaces int, v string) string {
			return indent(spaces, v)
		},
	}

	tmpl, err := template.New("lima").Funcs(funcMap).Parse(limaTemplateContent)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	provisionScript := generateProvisionScript(cfg)

	data := struct {
		Config          *config.Config
		WorkspacePath   string
		ArtifactsPath   string
		ProvisionScript string
	}{
		Config:          cfg,
		WorkspacePath:   filepath.Join(projectDir, "workspace"),
		ArtifactsPath:   filepath.Join(projectDir, "artifacts"),
		ProvisionScript: provisionScript,
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	return buf.String(), nil
}

func generateProvisionScript(cfg *config.Config) string {
	return fmt.Sprintf(`#!/bin/bash
set -euo pipefail

# =============================================================================
# AgentBox Guest Provisioning Script
# Network is OPEN - proxy is used for API key injection only
# =============================================================================

echo "Starting AgentBox provisioning..."

# --- User Creation ---
if ! id -u agent >/dev/null 2>&1; then
    echo "Creating agent user..."
    useradd -m -s /bin/bash -G sudo agent
    echo "agent ALL=(ALL) NOPASSWD: /usr/bin/apt-get, /usr/bin/apt" > /etc/sudoers.d/agent
    chmod 0440 /etc/sudoers.d/agent
fi

# --- Proxy Configuration ---
# Proxy is optional - used for API key injection to configured hosts
# Get host gateway from default route (try lima0 first, fall back to any default)
HOST_GATEWAY=$(ip route | grep "default.*lima0" | head -1 | awk '{print $3}' || true)
if [ -z "$HOST_GATEWAY" ]; then
    HOST_GATEWAY=$(ip route | grep default | head -1 | awk '{print $3}' || true)
fi
PROXY_PORT=%d
PROXY_URL="http://${HOST_GATEWAY}:${PROXY_PORT}"

echo "Configuring proxy: ${PROXY_URL}"

# Set system-wide proxy in /etc/environment (read by PAM for all shells)
# This ensures proxy vars are available even in non-interactive shells
cat >> /etc/environment << EOF
HTTP_PROXY="${PROXY_URL}"
HTTPS_PROXY="${PROXY_URL}"
http_proxy="${PROXY_URL}"
https_proxy="${PROXY_URL}"
NO_PROXY="localhost,127.0.0.1,::1"
no_proxy="localhost,127.0.0.1,::1"
EOF

# Also save to environment.d for sourcing in bashrc
mkdir -p /etc/environment.d
cat > /etc/environment.d/proxy.conf << EOF
HTTP_PROXY=${PROXY_URL}
HTTPS_PROXY=${PROXY_URL}
http_proxy=${PROXY_URL}
https_proxy=${PROXY_URL}
NO_PROXY=localhost,127.0.0.1,::1
no_proxy=localhost,127.0.0.1,::1
EOF

# --- Mount Permissions ---
# Note: virtiofs mounts may not support permission changes from guest
# The mounts are configured with correct permissions from the host side
echo "Mount points ready: /workspace, /artifacts"

# --- Agent Profile ---
echo "Configuring agent shell environment..."

# Add proxy and workspace config to .profile (runs for login shells before .bashrc guard)
cat >> /home/agent/.profile << 'PROFILE'

# AgentBox proxy configuration
export HTTP_PROXY="$HTTP_PROXY"
export HTTPS_PROXY="$HTTPS_PROXY"
export http_proxy="$http_proxy"
export https_proxy="$https_proxy"
export NO_PROXY="$NO_PROXY"
export no_proxy="$no_proxy"

# Start in workspace for login shells
cd /workspace 2>/dev/null || true
PROFILE

# Add PS1 customization to .bashrc (only for interactive shells)
mkdir -p /home/agent/.bashrc.d
cat > /home/agent/.bashrc.d/agentbox.sh << 'BASHRC'
# AgentBox environment - interactive shell customizations
export PS1='[agentbox] \u@\h:\w\$ '
BASHRC

chown -R agent:agent /home/agent/.bashrc.d

# Ensure .bashrc sources .bashrc.d
if ! grep -q 'bashrc.d' /home/agent/.bashrc 2>/dev/null; then
    echo 'for f in ~/.bashrc.d/*.sh; do [ -r "$f" ] && source "$f"; done' >> /home/agent/.bashrc
fi

# --- Mark Ready ---
touch /etc/agentbox-ready
echo "AgentBox provisioning complete!"
echo "Network is OPEN - API keys are injected by host proxy"
`, cfg.Network.ProxyPort)
}
